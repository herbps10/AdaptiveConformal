#' Initialize an Adaptive Conformal Inference algorithm.
#'
#' @param Y optional vector of observations.
#' @param predictions optional vector or matrix of predictions.
#' @param X optional matrix of covariates
#' @param training optional boolean indicating if the supplied Y and prediction values should be treated as training data (not used to update ACI parameters, but used in e.g. calculating conformity scores).
#' @param alpha desired empirical coverage. That is, the method will target alpha * 100\% prediction intervals.
#' @param method a string specifying the Adaptive Conformal Inference method to use.
#'   The available methods are:
#'   \describe{
#'      \item{'RollingRC'}{Rolling Risk Control \insertCite{feldman2023rollingrisk}{AdaptiveConformal}.
#'      Requires specification of a positive learning rate gamma.}
#'      \item{'AgACI'}{Aggregated ACI \insertCite{zaffran2022agaci}{AdaptiveConformal}.
#'      Multiple ACI algorithms are executed for a grid of learning rates, and the resulting intervals are combined using the Bernstein Online Aggregation method
#'      for online aggregation of experts.}
#'      \item{'FACI'}{Fully Adaptive Conformal Inference \insertCite{gibbs2022faci}{AdaptiveConformal}.}
#'   }
#' @param parameters a list of parameters that depend on the chosen ACI method.
#' \describe{
#'    \item{gamma}{A positive number specifying the learning rate. For method "RollingRC".}
#'    \item{gamma_grid}{A grid of positive learning rates. For method "AgACI" and "FACI.}
#'    \item{theta0}{Initial value for theta parameter.}
#'    \item{interval_constructor}{
#'      Specifies how the prediction intervals are to be formed. Only for "RollingRC" and "AgACI". For "FACI", it is always set to "conformal".
#'      \itemize{
#'        \item "conformal": the interval is formed as [prediction - S, prediction + S], where S is the theta*100\% quantile of the previously observed.
#'        This is the default for "RollingRC" and "AgACI".
#'        \item "linear": the interval is formed as [prediction - theta, prediction + theta].
#'        conformity scores.
#'        \item A function (see details)
#'      }
#'    }
#'    \item{conformity_score}{
#'      Specifies the conformity scores to use for constructing prediction intervals. Only applicable if interval_constructor = "conformal".
#'      Current options are:
#'      \itemize{
#'        \item "absolute_error": S_t = |Y_t - prediction_t|. This is the default.
#'        \item A function (see details)
#'      }
#'    }
#' }
#' @details
#'   The prediction intervals are formed by an \emph{interval constructor} function.
#'   A custom interval constructor can be supplied as a function of the form
#'   \code{function(prediction, theta, object)} where \code{prediction} is the predicted value of the outcome,
#'   \code{theta} is a parameter that controls the size of the interval, and \code{object} is an ACI object.
#'
#'   The "conformal" interval constructor forms intervals using quantiles of the previous \emph{conformity scores} of
#'   the predicted outcomes. The default conformity score is the absolute residual: S_t = |Y_t - prediction_t|, where S_t is the
#'   conformity score, Y_t is the observed value, and prediction_t is the predicted value.
#'   A custom conformity score can be supplied as a function of the form
#'   \code{function(Y, prediction)}.
#'
#' @returns
#' An object with class "aci". Important parameters include:
#' \describe{
#'   \item{intervals}{A matrix that contains the prediction intervals generated by the method.}
#'   \item{covered}{A logical vector indicating if each observation was within (TRUE) or outside (FALSE) the prediction interval.}
#'   \item{training}{A logical vector indicating if each observation and prediction was used solely as context for the method (TRUE)
#'   or if they were used to update the underlying ACI method (FALSE)}.
#' }
#'
#' @examples
#' # Generate a simple time series of observations
#' N <- 1e3
#' Y <- rnorm(N)
#' predictions <- rep(0, N) # predict 0 at very timestep
#'
#' # Apply Rolling Risk Control algorithm with learning rate gamma = 0.01
#' # with goal of 90\% prediction intervals
#' result <- aci(Y, predictions, method = "RollingRC", alpha = 0.9,
#'               parameters = list(gamma = 0.01))
#' summary(result)
#'
#' # Supply a custom conformity score function
#' conformity_score_squared_error <- function(Y, prediction) (Y - prediction)^2
#' result <- aci(Y, predictions, method = "RollingRC", alpha = 0.9,
#'               parameters = list(gamma = 0.01, conformity_score = conformity_score_squared_error))
#' summary(result)
#'
#' @references
#'   \insertAllCited{}
#'
#' @importFrom Rdpack reprompt
#'
#' @export
aci <- function(Y = NULL, predictions = NULL, X = NULL, training = FALSE, alpha = 0.95, method = "AgACI", parameters = list()) {
  method <- match.arg(method, aci_methods())

  object <- list(
    method = method,
    alpha = alpha,
    Y = NULL,
    predictions = NULL,
    X = NULL,
    intervals = matrix(ncol = 2, nrow = 0),
    covered = numeric(0),
    parameters = parameters,
    internal = NULL,
    coverage = NULL,
    mean_width = NULL,
    mean_interval_loss = NULL,
    training = logical(0)
  )

  if(is.null(X)) {
    object$X <- matrix(ncol = 0, nrow = 0)
  }
  else {
    object$X <- matrix(ncol = ncol(X), nrow = 0)
  }

  if(!is.null(predictions)) {
    if(is.vector(predictions)) {
      predictions <- matrix(predictions, ncol = 1)
    }
  }

  initializers <- list(
    RollingRC = initialize_rolling_rc,
    AgACI = initialize_ag_aci,
    FACI = initialize_faci,
    GACI = initialize_gaci,
    "SF-OGD" = initialize_sfogd,
    SAOCP = initialize_saocp
  )

  object <- initializers[[method]](object)

  class(object) <- "aci"

  if(!is.null(Y) || !is.null(predictions)) {
    object <- update.aci(object, newY = Y, newpredictions = predictions, newX = X, training = training)
  }

  return(object)
}

aci_methods <- function() c("AgACI", "RollingRC", "FACI", "GACI", "SF-OGD", "SAOCP")

#' Compute a conformal prediction interval
#'
#' @param object object of class "aci"
#' @param prediction vector or matrix of predictions to use for forming the conformal prediction interval
#' @param ... additional arguments (currently ignored)
#' @export
predict.aci <- function(object, prediction = 0, X = NULL, ...) {
  method <- match.arg(object$method, aci_methods())

  funs <- list(
    RollingRC = predict_rolling_rc,
    AgACI = predict_ag_aci,
    FACI = predict_faci,
    GACI = predict_gaci,
    "SF-OGD" = predict_sfogd,
    SAOCP = predict_saocp
  )

  if(!is.null(X) && is.vector(X)) {
    X <- matrix(X, ncol = length(X))
  }

  interval <- funs[[method]](object, prediction, X)
  names(interval) <- c(paste0((1 - object$alpha) / 2 * 100, "%"), paste0((1 - (1 - object$alpha) / 2) * 100, "%"))
  interval
}


#' Print an ACI object
#'
#' @param x object of class "aci"
#' @param ... additional arguments (currently ignored)
#'
#' @export
print.aci <- function(x, ...) {
  cat(paste0("ACI object (method=", x$method, ") with ", length(x$Y), " observations.\n"))
}

#' Summary of an ACI object
#'
#' @param object object of class "aci"
#' @param ... additional arguments (currently ignored)
#'
#' @export
summary.aci <- function(object, ...) {
  observed <- object$training == FALSE

  N_intervals <- sum(observed)
  within <- sum(object$Y[observed] >= object$intervals[observed, 1] & object$Y[observed] <= object$intervals[observed, 2])

  cat(paste0("Method: ", object$method, "\n"))
  if(sum(observed) == 0) {
    cat("No intervals have been produced by this method yet.")
  }
  else {
    cat(paste0("Empirical coverage: ", format(round(object$coverage * 100, 2)), "% (", within, "/", N_intervals, ")\n"))
    cat(paste0("Mean interval width: ", format(round(object$mean_width, 3)), "\n"))
    cat(paste0("Mean interval loss: ", format(round(object$mean_interval_loss, 3)), "\n"))

    if(!is.null(object$X) && nrow(object$X) > 0) {
      cat(paste0("Conditional coverage: \n"))
      for(index in 1:length(object$conditional_coverage)) {
        cat(paste0(colnames(object$conditional_coverage)[index], ":\t", format(round(object$conditional_coverage[index] * 100, 2)), "%\n"))
      }
    }
  }
}
